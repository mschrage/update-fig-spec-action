"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-use-before-define */
var ts_morph_1 = require("ts-morph");
var prettier_1 = __importDefault(require("prettier"));
var presets_1 = require("./presets");
var project = new ts_morph_1.Project();
function parseFile(filePath, input) {
    return project.createSourceFile(filePath, input, { overwrite: true });
}
function setupFile(path, file, getDefaultExport) {
    if (getDefaultExport === void 0) { getDefaultExport = true; }
    var sourceFile = parseFile(path, file);
    if (getDefaultExport) {
        var sourceFileDefaultExport = sourceFile.getDefaultExportSymbol();
        if (!sourceFileDefaultExport)
            throw new Error("A Fig spec file should default as default a completion spec object\nRaised at: ".concat(path));
        return [sourceFile, sourceFileDefaultExport];
    }
    return [sourceFile];
}
function isSpecObject(statement, name) {
    if (ts_morph_1.Node.isVariableStatement(statement)) {
        var declarations = statement.getDeclarationList().getDeclarations();
        return declarations.some(function (declaration) { return declaration.getName() === name; });
    }
    return false;
}
/**
 * @returns {ts.Node[]} the node path of the specified node, it should be read from the end to the start
 */
// TODO: find a way to avoid recalculating this every time. It may be expensive for complex specs
function generateNodePath(node) {
    var currentNode = node;
    var path = [];
    do {
        path.push(currentNode);
        currentNode = currentNode.parent;
    } while (!ts_morph_1.ts.isVariableDeclaration(currentNode));
    return path;
}
function compareObjectLiteralElementLike(nodeA, nodeB) {
    if (nodeA.kind !== nodeB.getKind())
        return false;
    if (ts_morph_1.Node.isPropertyAssignment(nodeB)) {
        return compareExpressions(nodeA.initializer, nodeB.getInitializer());
    }
    // true for ShorthandPropertyAssignment, SpreadAssignment
    return true;
}
function compareExpressions(expressionA, expressionB) {
    if (!expressionA || !expressionB)
        return false;
    if (expressionA.kind !== expressionB.getKind())
        return false;
    if (ts_morph_1.Node.isArrayLiteralExpression(expressionB)) {
        var elementsA = expressionA.elements;
        var elementsB_1 = expressionB.getElements();
        return (elementsA.length === elementsB_1.length &&
            elementsA.every(function (element, index) { return compareExpressions(element, elementsB_1[index]); }));
    }
    if (ts_morph_1.Node.isStringLiteral(expressionB) ||
        ts_morph_1.Node.isNoSubstitutionTemplateLiteral(expressionB) ||
        ts_morph_1.Node.isNumericLiteral(expressionB)) {
        // @ts-expect-error
        return expressionB.getLiteralText() === expressionA.text;
    }
    if (ts_morph_1.Node.isObjectLiteralExpression(expressionB)) {
        var propertiesA = expressionA.properties;
        var propertiesB_1 = expressionB.getProperties();
        return (propertiesA.length === propertiesB_1.length &&
            propertiesA.every(function (property, index) {
                var _a, _b;
                var propertyText = (_a = property.name) === null || _a === void 0 ? void 0 : _a.getText();
                // if the properties at the same index has the same name we avoid an useless search
                if (propertyText === ((_b = propertiesB_1[index].compilerNode.name) === null || _b === void 0 ? void 0 : _b.getText())) {
                    return compareObjectLiteralElementLike(property, propertiesB_1[index]);
                }
                // otherwise we need to search an eventual property with the same name
                var foundProperty = propertiesB_1.find(function (prop) { var _a; return propertyText === ((_a = prop.compilerNode.name) === null || _a === void 0 ? void 0 : _a.getText()); });
                if (!foundProperty)
                    return false;
                return compareObjectLiteralElementLike(property, foundProperty);
            }));
    }
    // fallback for all other nodes that should just have the same kind e.g. FalseNode and TrueNode
    return true;
}
function resolveArrayLiteral(path, arrayNode) {
    var _a;
    var newPath = path.slice(0, -1);
    var currentPathItem = newPath[newPath.length - 1];
    var elements = arrayNode.getElements();
    // The assertion below is an identity, we just use it for type casting
    if (ts_morph_1.ts.isObjectLiteralExpression(currentPathItem)) {
        // Check if the object has a name property and get its value
        var nameToFind = (_a = currentPathItem.properties.filter(function (prop) {
            return ts_morph_1.ts.isPropertyAssignment(prop) && ts_morph_1.ts.isIdentifier(prop.name) && prop.name.text === "name";
        })[0]) === null || _a === void 0 ? void 0 : _a.initializer;
        if (nameToFind) {
            for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
                var element = elements_1[_i];
                if (ts_morph_1.Node.isObjectLiteralExpression(element)) {
                    var nameProp = element.getProperty("name");
                    if (nameProp && ts_morph_1.Node.isPropertyAssignment(nameProp)) {
                        var initializer = nameProp.getInitializer();
                        if (compareExpressions(nameToFind, initializer)) {
                            return resolve(newPath, element);
                        }
                    }
                }
            }
        }
        else {
            // check which is the index of currentPathItem in the parent ArrayExpression
            var foundIndex = currentPathItem.parent.elements.findIndex(function (arrayElement) { return arrayElement === currentPathItem; });
            var element = elements[foundIndex];
            if (element && ts_morph_1.Node.isObjectLiteralExpression(element)) {
                return resolve(newPath, element);
            }
        }
    }
    return undefined;
}
function resolveObjectLiteral(path, objectNode) {
    var newPath = path.slice(0, -1);
    var currentPathItem = newPath[newPath.length - 1];
    // expect child item of an ObjectLiteral to be a PropertyAssignment
    if (!(ts_morph_1.ts.isPropertyAssignment(currentPathItem) && ts_morph_1.ts.isIdentifier(currentPathItem.name))) {
        return undefined;
    }
    var propNameToFind = currentPathItem.name.text;
    var props = objectNode.getProperties();
    for (var _i = 0, props_1 = props; _i < props_1.length; _i++) {
        var prop = props_1[_i];
        if (ts_morph_1.Node.isPropertyAssignment(prop) && prop.getName() === propNameToFind) {
            // if there is a matching prop and this is the last one item of the path return the prop.
            return resolve(newPath.slice(0, -1), prop.getInitializer());
        }
    }
    if (newPath.length === 1) {
        // if the last property of the path is only in the old spec (still needs to be added to the new one)
        return objectNode;
    }
    return undefined;
}
// The first item of a path is always a PropertyAssignment (the first is effectively the last item, the one we are looking for)
function resolve(path, baseNode) {
    if (!path.length)
        return baseNode;
    var currentItem = path[path.length - 1];
    if (ts_morph_1.ts.isObjectLiteralExpression(currentItem) && ts_morph_1.Node.isObjectLiteralExpression(baseNode)) {
        return resolveObjectLiteral(path, baseNode);
    }
    if (ts_morph_1.ts.isArrayLiteralExpression(currentItem) && ts_morph_1.Node.isArrayLiteralExpression(baseNode)) {
        return resolveArrayLiteral(path, baseNode);
    }
    return undefined;
}
function resolveAndUpdateNodePath(path, newSpec, nodeToAdd) {
    var statement = newSpec.getFirstDescendantByKind(ts_morph_1.ts.SyntaxKind.VariableDeclaration);
    if (!statement)
        throw new Error("The new spec should contain one exported completion spec object");
    var statementInitializer = statement.getInitializer();
    if (statementInitializer && ts_morph_1.Node.isObjectLiteralExpression(statementInitializer)) {
        var out = resolve(path, statementInitializer);
        if (out && ts_morph_1.Node.isObjectLiteralExpression(out)) {
            out.addPropertyAssignment(nodeToAdd);
            return true;
        }
        // if Node.isPropertyAssignement(out) -> the property already exist at the specified path. We keep the updated one.
        return false;
    }
    throw new Error("The new spec file should contain exactly one variable declaration containing the spec object.");
}
function getFirstParentProperty(nodePath) {
    var i = 1; // exclude the first element as we know it is a property (the leaf property)
    while (i <= nodePath.length - 1) {
        var node = nodePath[i];
        if (ts_morph_1.ts.isPropertyAssignment(node)) {
            return node;
        }
        i += 1;
    }
    return undefined;
}
function getObservedSet(updatable, parentProperty) {
    if (!parentProperty)
        return updatable.commandProps; // we are handling a top-level command
    if (ts_morph_1.ts.isIdentifier(parentProperty.name)) {
        var parentPropText = parentProperty.name.text;
        // eslint-disable-next-line no-nested-ternary
        return parentPropText === "subcommands"
            ? updatable.commandProps
            : parentPropText === "options"
                ? updatable.optionProps
                : updatable.argProps; // parentPropText === "args"
    }
    return undefined;
}
// `statement` can only be one of the top-level statements
function traverseSpecs(statement, destination, updatableProps) {
    statement.transform(function (traversal) {
        var node = traversal.visitChildren();
        if (ts_morph_1.ts.isPropertyAssignment(node) && ts_morph_1.ts.isIdentifier(node.name)) {
            var nodePath = generateNodePath(node);
            var parentProperty = getFirstParentProperty(nodePath);
            var observedSet = getObservedSet(updatableProps, parentProperty);
            if (observedSet && !observedSet.has(node.name.text)) {
                resolveAndUpdateNodePath(nodePath, destination, {
                    name: node.name.text,
                    initializer: node.initializer.getText(),
                });
            }
        }
        return node;
    });
}
function getPreset(_a) {
    var preset = _a.preset, _b = _a.ignore, ignore = _b === void 0 ? {} : _b;
    // Props updated by the eventual CLI tool integration (preset)
    var updatableProps = preset ? presets_1.presets[preset] : undefined;
    // If not preset was specified we default to the defaultPreset excluding all props the user ignored
    if (!updatableProps) {
        var _c = ignore.commandProps, commandProps = _c === void 0 ? [] : _c, _d = ignore.optionProps, optionProps = _d === void 0 ? [] : _d, _e = ignore.argProps, argProps = _e === void 0 ? [] : _e, _f = ignore.commonProps, commonProps = _f === void 0 ? [] : _f;
        for (var _i = 0, commandProps_1 = commandProps; _i < commandProps_1.length; _i++) {
            var commandProp = commandProps_1[_i];
            presets_1.defaultPreset.commandProps.add(commandProp);
        }
        for (var _g = 0, optionProps_1 = optionProps; _g < optionProps_1.length; _g++) {
            var optionProp = optionProps_1[_g];
            presets_1.defaultPreset.optionProps.add(optionProp);
        }
        for (var _h = 0, argProps_1 = argProps; _h < argProps_1.length; _h++) {
            var argProp = argProps_1[_h];
            presets_1.defaultPreset.argProps.add(argProp);
        }
        for (var _j = 0, commonProps_1 = commonProps; _j < commonProps_1.length; _j++) {
            var commonProp = commonProps_1[_j];
            presets_1.defaultPreset.commandProps.add(commonProp);
            presets_1.defaultPreset.optionProps.add(commonProp);
            presets_1.defaultPreset.argProps.add(commonProp);
        }
        updatableProps = presets_1.defaultPreset;
    }
    return updatableProps;
}
function merge(oldFileContent, newFileContent, options) {
    var updatableProps = getPreset(options);
    var _a = setupFile("oldfile.ts", oldFileContent), oldSourceFile = _a[0], oldSourceFileDefaultExport = _a[1];
    var newSourceFile = setupFile("newfile.ts", newFileContent)[0];
    /// MARK: Work on old source file by extracting top level statements
    var specNodeName;
    // It should contain exactly one declaration since it is a default export
    var exportDeclaration = oldSourceFileDefaultExport.getDeclarations()[0];
    if (!(exportDeclaration && ts_morph_1.Node.isExportAssignment(exportDeclaration))) {
        throw new Error();
    }
    var exportDeclarationExpression = exportDeclaration.getExpression();
    if (ts_morph_1.Node.isIdentifier(exportDeclarationExpression)) {
        specNodeName = exportDeclarationExpression.getText();
    }
    else if (ts_morph_1.Node.isObjectLiteralExpression(exportDeclarationExpression)) {
        throw new Error("You should not directly export the spec object, but you need to assign it to a variable before.");
    }
    else {
        throw new Error("Default export should be an Identifier.");
    }
    var diffTopLevelNodes = ["", "", ""];
    var statements = oldSourceFile.getStatements();
    var state = 0;
    for (var _i = 0, statements_1 = statements; _i < statements_1.length; _i++) {
        var statement = statements_1[_i];
        if (isSpecObject(statement, specNodeName)) {
            traverseSpecs(statement, newSourceFile, updatableProps);
            state += 1;
        }
        else if (statement === exportDeclaration) {
            state += 1;
        }
        else {
            diffTopLevelNodes[state] += statement.print();
        }
    }
    /// MARK: Save top level statements of the old file to the new source file
    newSourceFile.insertStatements(2, diffTopLevelNodes[2]);
    newSourceFile.insertStatements(1, diffTopLevelNodes[1]);
    newSourceFile.insertStatements(0, diffTopLevelNodes[0]);
    return prettier_1.default.format(ts_morph_1.ts.createPrinter().printFile(newSourceFile.compilerNode), {
        parser: "typescript",
        semi: false,
        singleQuote: true,
    });
}
exports.default = merge;
